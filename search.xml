<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gRPC demo</title>
      <link href="/2019/11/27/grpc-demo/"/>
      <url>/2019/11/27/grpc-demo/</url>
      
        <content type="html"><![CDATA[<h1 id="初识gRPC"><a href="#初识gRPC" class="headerlink" title="初识gRPC"></a>初识gRPC</h1><blockquote><p> Author：<a href="https://github.com/Voluee">Voluee</a> </p><p> 记录学习gRPC的过程与消化</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://www.oschina.net/p/grpc-framework" target="_blank" rel="noopener">gRPC</a>  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持。</p><p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p><h2 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h2><p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p><p><img src="https://www.grpc.io/img/grpc_concept_diagram_00.png" alt="grpc_concept_diagram_00"></p><p>gRPC 客户端和服务端可以在多种环境中运行和交互 - 从 google 内部的服务器到你自己的笔记本，并且可以用任何 gRPC <a href="http://doc.oschina.net/grpc?t=58008#quickstart" target="_blank" rel="noopener">支持的语言</a>来编写。所以，你可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。此外，Google 最新 API 将有 gRPC 版本的接口，使你很容易地将 Google 的功能集成到你的应用里。</p><h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 <em>protocol buffers*，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 *proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://doc.oschina.net/https：//developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。</p><h4 id="Protocol-buffers-版本"><a href="#Protocol-buffers-版本" class="headerlink" title="Protocol buffers 版本"></a>Protocol buffers 版本</h4><p>尽管 protocol buffers 对于开源用户来说已经存在了一段时间，例子内使用的却一种名叫 proto3 的新风格的 protocol buffers，它拥有轻量简化的语法、一些有用的新功能，并且支持更多新语言。当前针对 Java 和 C++ 发布了 beta 版本，针对 JavaNano（即 Android Java）发布 alpha 版本，在<a href="http://doc.oschina.net/https：//github.com/google/protobuf/releases" target="_blank" rel="noopener">protocol buffers Github 源码库里</a>有 Ruby 支持， 在<a href="http://doc.oschina.net/https：//github.com/golang/protobuf" target="_blank" rel="noopener">golang/protobuf Github 源码库</a>里还有针对 Go 语言的生成器， 对更多语言的支持正在开发中。 你可以在 <a href="http://doc.oschina.net/https：//developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3 语言指南</a>里找到更多内容， 在与当前默认版本的<a href="http://doc.oschina.net/https：//github.com/google/protobuf/releases" target="_blank" rel="noopener">发布说明</a>比较，看到两者的主要不同点。更多关于 proto3 的文档很快就会出现。虽然你<em>可以</em>使用 proto2 (当前默认的 protocol buffers 版本)， 我们通常建议你在 gRPC 里使用 proto3，因为这样你可以使用 gRPC 支持全部范围的的语言，并且能避免 proto2 客户端与 proto3 服务端交互时出现的兼容性问题，反之亦然。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github-gitlab同时使用</title>
      <link href="/2019/11/20/github-gitlab-both/"/>
      <url>/2019/11/20/github-gitlab-both/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://github.com/Voluee">Voluee</a></p><p>由于公司团队使用 GitLab 来托管代码，同时，个人在 Github 上还有一些代码仓库，可公司邮箱与个人邮箱是不同的，由此产生的 SSH key 也是不同的，这就造成了冲突 ,如何在一台机器上面同时使用 Github 与 Gitlab 的服务？</p></blockquote><h1 id="github和gitlab同时使用"><a href="#github和gitlab同时使用" class="headerlink" title="github和gitlab同时使用"></a>github和gitlab同时使用</h1><h2 id="问题产生场景"><a href="#问题产生场景" class="headerlink" title="问题产生场景"></a>问题产生场景</h2><h3 id="无密码与远程服务器交互的秘密-SSH"><a href="#无密码与远程服务器交互的秘密-SSH" class="headerlink" title="无密码与远程服务器交互的秘密 - SSH"></a>无密码与远程服务器交互的秘密 - SSH</h3><p>如果采用<code>ssh</code> 协议或者<code>git 协议</code>通过终端命令对远程仓库进行<code>push</code>操作的时候，大概的过程如下：（前提在 Github 上已经配置的本机的 SSH Public Key）</p><ul><li>客户端发起一个 Public Key 的认证请求，并发送RSA Key的模数作为标识符。（关于 RSA Key 详细 <a href="https://en.wikipedia.org/wiki/RSA_(algorithm)" target="_blank" rel="noopener">维基百科</a>）</li><li>服务端检查是否存在请求帐号的公钥（Linux中存储在~/.ssh/authorized_keys文件中），以及其拥有的访问权限。</li><li>服务端使用对应的公钥对一个随机的256位的字符串进行加密，并发送给客户端。</li><li>客户端使用私钥对字符串进行解密，并将其结合session id生成一个MD5值发送给服务端。 结合session id的目的是为了避免攻击者采用重放攻击（replay attack）。</li><li>服务端采用同样的方式生成MD5值与客户端返回的MD5值进行比较，完成对客户端的认证。</li><li>将push的内容进行加密与服务端传输数据。<br> 关于 SSH，请查看 <a href="http://erik-2-blog.logdown.com/posts/74081-ssh-principle" target="_blank" rel="noopener">SSH原理简介</a> ，更通俗易懂的文章请查看<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">阮一峰-SSH原理与运用（一）：远程登录</a> 。</li></ul><h2 id="具体场景"><a href="#具体场景" class="headerlink" title="具体场景"></a>具体场景</h2><p>无论使用哪种代码托管服务商，对于 Git 而言，<code>邮箱</code>是识别用户的唯一手段，所以对于不同的服务商，由于邮箱不同，那么通过邮件名创建的 SSH Key 自然是不同的，这时候在不同的服务商之间进行<code>push</code>命令的时候，Git 是不知道使用哪个 SSH Key ，自然导致 <code>push</code> 的失败。场景如下：</p><ul><li>在公司团队使用搭建的 Gitlab 服务，提交邮箱<code>chaoyi.hu@zljr.com</code>。个人 Github 服务，提交邮箱<code>58830130@qq.com</code>。</li><li>有两个Github账户，不同的账户提交不同的仓库内容。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：同一个邮箱"><a href="#方案一：同一个邮箱" class="headerlink" title="方案一：同一个邮箱"></a>方案一：同一个邮箱</h3><p>由于<code>邮箱</code>是识别的唯一手段，那么自然的，这两者采用同一个邮箱，生成的 public key 也会是同一个，上传到 Github 或者 Gitlab 上面，在 Git 的配置中 ，设置好 Global 的配置 ：<code>git config --global user.name 'Voluee' &amp;&amp; git config --global user.email '58830130@qq.com'</code> 进行日常的开发是没有问题的。</p><p>实际生活中采用同一个邮箱的可能性并不是太大，这就引出了方案二</p><h3 id="方案二：基于config文件"><a href="#方案二：基于config文件" class="headerlink" title="方案二：基于config文件"></a>方案二：基于config文件</h3><p>所谓的方案二，原理上就是对 SSH 协议配置 config 文件，对不同的域名采用不同的认证密钥。</p><h4 id="git-config-介绍"><a href="#git-config-介绍" class="headerlink" title="git config 介绍"></a>git config 介绍</h4><p>Git有一个工具被称为git config，它允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。这些变量可以被存储在三个不同的位置：</p><ul><li>/etc/gitconfig 文件：包含了适用于系统所有用户和所有库的值。如果你传递参数选项<code>’--system’</code>给 git config，它将明确的读和写这个文件。</li><li>~/.gitconfig 文件 ：具体到你的用户。你可以通过传递 <code>‘--global’</code> 选项使Git 读或写这个特定的文件。</li><li>位于 Git 目录的 config 文件 (也就是 .git/config) ：无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。因此，在 .git/config 中的值覆盖了在/etc/gitconfig中的同一个值，可以通过传递<code>‘--local’</code>选项使Git 读或写这个特定的文件。<br> 由于采用了不同的邮箱，对不同的服务商进行提交，所以此时我们经常配置的<code>git config --global</code>就不能常用了，必须在每个仓库的目录下进行配置自己的用户名、邮箱。（嫌麻烦？那么可以这么解决，由于个人的 Github 上有较多的仓库，而自己团队的代码基本上都是稳定的，有数的几个，所以在<code>git config --global user.name "Voluee" &amp;&amp; git config --global user.email "58830130@qq.com"</code> 中全局配置的是个人邮箱，在团队的项目单独配置邮箱）</li></ul><h4 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h4><h6 id="1-配置-Git-用户名、邮箱"><a href="#1-配置-Git-用户名、邮箱" class="headerlink" title="1. 配置 Git 用户名、邮箱"></a>1. 配置 Git 用户名、邮箱</h6><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 全局配置，Github仓库中默认使用此配置</span><span class="token function">git</span> config --global user.name <span class="token string">"Voluee"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> config --global user.email <span class="token string">"58830130@qq.com"</span><span class="token comment" spellcheck="true"># 团队项目配置，每次新创建一个项目，需要执行下</span><span class="token function">git</span> config --local user.name <span class="token string">"Hu Chaoyi"</span> <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> config --local user.email <span class="token string">"chaoyi.hu@zljr.com"</span></code></pre><h6 id="2-生成-ssh-key-上传到-Github-Gitlab"><a href="#2-生成-ssh-key-上传到-Github-Gitlab" class="headerlink" title="2.生成 ssh key 上传到 Github/Gitlab"></a>2.生成 ssh key 上传到 Github/Gitlab</h6><p>ssh key 默认生成后保存在 ~/.ssh/目录下 ，分别为gitlab_id_rsa和github_id_rsa两个文件，由于我们需要分开配置，所以这么做：</p><pre class=" language-ruby"><code class="language-ruby"><span class="token comment" spellcheck="true">#创建gitlab的SSH-Key</span>ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span><span class="token constant">C</span> <span class="token string">"chaoyi.hu@zljr.com"</span> <span class="token operator">-</span>f <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>gitlab_id_rsa<span class="token comment" spellcheck="true">#创建github的SSH-Key</span>ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span><span class="token constant">C</span> <span class="token string">"58830130@qq.com"</span> <span class="token operator">-</span>f <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>github_id_rsa    </code></pre><p>命令执行完成后，这时<code>~/.ssh</code>目录下会多出<code>gitlab_id_rsa</code>和<code>github_id_rsa</code>四个文件，<code>xxx.pub</code>里保存的就是我们要使用的key，这个key就是用来上传到Gitlab和GitHub上的。</p><h6 id="3-配置-config-文件"><a href="#3-配置-config-文件" class="headerlink" title="3.配置 config 文件"></a>3.配置 config 文件</h6><p>在 <code>~/.ssh</code>目录下，如果不存在，则新建 <code>touch ~/.ssh/config</code>文件 ，文件内容添加如下：</p><pre class=" language-jsx"><code class="language-jsx">#gitlabHost <span class="token punctuation">[</span>这里填gitlab真实地址<span class="token punctuation">,</span>就是clone的前缀<span class="token punctuation">]</span>    HostName <span class="token punctuation">[</span>这里填gitlab真实地址<span class="token punctuation">]</span>    PreferredAuthentications publickey    IdentityFile <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>gitlab_id_rsa#githubHost github    HostName github<span class="token punctuation">.</span>com    PreferredAuthentications publickey    IdentityFile <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>ssh<span class="token operator">/</span>github_id_rsa</code></pre><h6 id="4-上传public-key-到-Github-Gitlab"><a href="#4-上传public-key-到-Github-Gitlab" class="headerlink" title="4.上传public key 到 Github/Gitlab"></a>4.上传public key 到 Github/Gitlab</h6><p>以Github为例，过程如下：</p><ul><li><p>登录github    –&gt;    点击右上方的头像选择settings图标    –&gt;    点击左边界面的 SSH keys    —&gt;    点击New SSH key    </p><p>–&gt;    然后将上面拷贝的 ~/.ssh/github_id_rsa 文件内容粘帖到key一栏，再点击“Add SSH key”按钮就可以了</p></li><li><p>添加过程github会提示你输入一次你的github密码 ，确认后即添加完毕。 </p></li></ul><h6 id="5-验证是否OK"><a href="#5-验证是否OK" class="headerlink" title="5.验证是否OK"></a>5.验证是否OK</h6><p>由于每个托管商的仓库都有唯一的后缀，比如 Github的是 <code>git@github.com:*</code>，所以可以这样测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.comHi ciqing<span class="token operator">!</span> You've successfully authenticated, but GitHub does not provide shell access.<span class="token function">ssh</span> -T git@<span class="token punctuation">[</span>这里填gitlab真实地址,就是clone的前缀<span class="token punctuation">]</span>Welcome to GitLab, chaoyi.hu<span class="token operator">!</span></code></pre><p>看到这些<code>Welcome</code> 信息，说明就是OK的了</p><h2 id="分享一些指令"><a href="#分享一些指令" class="headerlink" title="分享一些指令"></a>分享一些指令</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config --system --list<span class="token function">git</span> config --global  --list<span class="token function">git</span> config --local  --listCMD，git_bash不走代理，所以得配置，前提是你有vpn已经代理了指定端口<span class="token keyword">set</span> http_proxy<span class="token operator">=</span>http://127.0.0.1:1080 <span class="token operator">&amp;&amp;</span> <span class="token keyword">set</span> https_proxy<span class="token operator">=</span>http://127.0.0.1:1080 <span class="token operator">&amp;&amp;</span> <span class="token keyword">set</span> http_proxy_user<span class="token operator">=</span>123 <span class="token operator">&amp;&amp;</span> <span class="token keyword">set</span> http_proxy_pass<span class="token operator">=</span>123</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【reprinted】Docker principle</title>
      <link href="/2019/04/05/docker-principle/"/>
      <url>/2019/04/05/docker-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="【转载】深入理解Docker原理"><a href="#【转载】深入理解Docker原理" class="headerlink" title="【转载】深入理解Docker原理"></a>【转载】深入理解Docker原理</h1><blockquote><p>本文用图文并茂的方式介绍了容器、镜像的区别和Docker每个命令后面的技术细节，能够很好的帮助读者深入理解Docker。</p></blockquote><h2 id="Image-Definition"><a href="#Image-Definition" class="headerlink" title="Image Definition"></a>Image Definition</h2><p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p><p>你可以在你的主机文件系统上找到有关这些层的文件。需要注意的是，在一个运行中的容器内部，这些层是不可见的。在我的主机上，我发现它们存在于/var/lib/docker/aufs目录下。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> tree -L 1 /var/lib/docker//var/lib/docker/├── aufs├── containers├── graph├── init├── linkgraph.db├── repositories-aufs├── tmp├── trust└── volumes7 directories, 2 files</code></pre><h2 id="Container-Definition"><a href="#Container-Definition" class="headerlink" title="Container Definition"></a>Container Definition</h2><p>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><p>要点：容器 = 镜像 + 读写层。并且容器的定义并没有提及是否要运行容器。</p><p>一个运行态容器（running container）被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。下面这张图片展示了一个运行中的容器。</p><p><a href="http://dockone.io/uploads/article/20190626/1ccc2aa9e11e25e5ed2efd18cf1052c4.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/1ccc2aa9e11e25e5ed2efd18cf1052c4.png" alt="4.png"></a></p><p>正是文件系统隔离技术使得Docker成为了一个前途无量的技术。一个容器中的进程可能会对文件进行修改、删除、创建，这些改变都将作用于可读写层（read-write layer）。下面这张图展示了这个行为。</p><p><a href="http://dockone.io/uploads/article/20190626/a20b70e3e4ca61faa2c3436e1bb2d93a.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/a20b70e3e4ca61faa2c3436e1bb2d93a.png" alt="5.png"></a></p><p>我们可以通过运行以下命令来验证我们上面所说的：</p><pre class=" language-bash"><code class="language-bash">docker run ubuntu <span class="token function">touch</span> happiness.txt</code></pre><p>即便是这个ubuntu容器不再运行，我们依旧能够在主机的文件系统上找到这个新文件。</p><pre class=" language-bash"><code class="language-bash"><span class="token function">find</span> / -name happiness.txt/var/lib/docker/aufs/diff/860a7b<span class="token punctuation">..</span>.889/happiness.txt</code></pre><h2 id="Image-Layer-Definition"><a href="#Image-Layer-Definition" class="headerlink" title="Image Layer Definition"></a>Image Layer Definition</h2><p>为了将零星的数据整合起来，我们提出了镜像层（image layer）这个概念。下面的这张图描述了一个镜像层，通过图片我们能够发现一个层并不仅仅包含文件系统的改变，它还能包含了其他重要信息。</p><p><strong>Metadata Location：</strong>我发现在我自己的主机上，镜像层（image layer）的元数据被保存在名为”json”的文件中，比如说：</p><pre class=" language-bash"><code class="language-bash">/var/lib/docker/graph/e809f156dc985<span class="token punctuation">..</span>./json</code></pre><p>e809f156dc985…就是这层的id</p><p>现在，让我们结合上面提到的实现细节来理解Docker的命令。</p><p><a href="http://dockone.io/uploads/article/20190626/062e7af0929dd205b2ac6efdd937d6f4.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/062e7af0929dd205b2ac6efdd937d6f4.png" alt="9.png"></a></p><p>docker create 命令为指定的镜像（image）添加了一个可读写层，构成了一个新的容器。注意，这个容器并没有运行。</p><p><a href="http://dockone.io/uploads/article/20190626/162f02c6f9dce4ccdaa0c6c676da2196.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/162f02c6f9dce4ccdaa0c6c676da2196.png" alt="10.png"></a></p><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start "></a>docker start <container-id></container-id></h3><p><a href="http://dockone.io/uploads/article/20190626/1c38d4735e9760bdca025ff50a1b5386.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/1c38d4735e9760bdca025ff50a1b5386.png" alt="11.png"></a><br>Docker start命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。</p><p><a href="http://dockone.io/uploads/article/20190626/01aedf55bd21abbe607b3864d76f0ec0.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/01aedf55bd21abbe607b3864d76f0ec0.png" alt="12.png"></a></p><p>看到这个命令，读者通常会有一个疑问：docker start 和 docker run命令有什么区别。</p><p><a href="http://dockone.io/uploads/article/20190626/275cc486d4ce7ecbdecf0ecc1de0a34b.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/275cc486d4ce7ecbdecf0ecc1de0a34b.png" alt="13.png"></a></p><p>从图片可以看出，docker run 命令先是利用镜像创建了一个容器，然后运行这个容器。这个命令非常的方便，并且隐藏了两个命令的细节，但从另一方面来看，这容易让用户产生误解。</p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p><a href="http://dockone.io/uploads/article/20190626/f05a2a8dfc6641d8237306ff575aa283.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/f05a2a8dfc6641d8237306ff575aa283.png" alt="14.png"></a></p><p>docker ps 命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，我们需要使用下面这个命令。</p><h3 id="docker-ps-–a"><a href="#docker-ps-–a" class="headerlink" title="docker ps –a"></a>docker ps –a</h3><p><a href="http://dockone.io/uploads/article/20190626/d7f7b0ada7fc1c641c90745a959f9c05.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/d7f7b0ada7fc1c641c90745a959f9c05.png" alt="15.png"></a></p><p>docker ps –a命令会列出所有的容器，不管是运行的，还是停止的。</p><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p><a href="http://dockone.io/uploads/article/20190626/d5b0b3e2e7acdcf35e7577d7670a46f7.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/d5b0b3e2e7acdcf35e7577d7670a46f7.png" alt="16.png"></a><br>docker images命令会列出了所有顶层（top-level）镜像。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们提出了top-level镜像。只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为顶层（top-level）镜像，并且每一个顶层镜像下面都隐藏了多个镜像层。</p><h3 id="docker-images-–a"><a href="#docker-images-–a" class="headerlink" title="docker images –a"></a>docker images –a</h3><p><a href="http://dockone.io/uploads/article/20190626/ce083575e95a0e46b105c3596c12ca71.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/ce083575e95a0e46b105c3596c12ca71.png" alt="17.png"></a></p><p>docker images –a命令列出了所有的镜像，也可以说是列出了所有的可读层。如果你想要查看某一个image-id下的所有层，可以使用docker history来查看。</p><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop "></a>docker stop <container-id></container-id></h3><p><a href="http://dockone.io/uploads/article/20190626/a41de8fe542efe25e3620691ad9238df.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/a41de8fe542efe25e3620691ad9238df.png" alt="18.png"></a><br>docker stop命令会向运行中的容器发送一个SIGTERM的信号，然后停止所有的进程。</p><h3 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill "></a>docker kill <container-id></container-id></h3><p><a href="http://dockone.io/uploads/article/20190626/ac1cbc31d4f191e26e05fb1a11f04d26.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/ac1cbc31d4f191e26e05fb1a11f04d26.png" alt="19.png"></a><br>docker kill 命令向所有运行在容器中的进程发送了一个不友好的SIGKILL信号。</p><p><a href="http://dockone.io/uploads/article/20190626/b701a3c51e7d1915da3bea0bc43efcd1.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/b701a3c51e7d1915da3bea0bc43efcd1.png" alt="20.png"></a></p><p>docker stop和docker kill命令会发送UNIX的信号给运行中的进程，docker pause命令则不一样，它利用了cgroups的特性将运行中的进程空间暂停。具体的内部原理你可以在这里找到：<a href="https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Doc … m.txt</a></p><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm "></a>docker rm <container-id></container-id></h3><p><a href="http://dockone.io/uploads/article/20190626/8fa2d6e19c29f18548624efd64eb6dfa.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/8fa2d6e19c29f18548624efd64eb6dfa.png" alt="21.png"></a></p><p>docker rm命令会移除构成容器的可读写层。注意，这个命令只能对非运行态容器执行。</p><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi "></a>docker rmi <container-id></container-id></h3><p><a href="http://dockone.io/uploads/article/20190626/32a7f413a5f8ff936dd0f4a31d25fdcc.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/32a7f413a5f8ff936dd0f4a31d25fdcc.png" alt="22.png"></a></p><p>docker rmi 命令会移除构成镜像的一个只读层。你只能够使用docker rmi来移除最顶层（top level layer）（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层。 </p><p><a href="http://dockone.io/uploads/article/20190626/3c02ccf4e7a2a353af065d93b26ae89e.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/3c02ccf4e7a2a353af065d93b26ae89e.png" alt="23.png"></a></p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit "></a>docker commit <container-id></container-id></h3><p>docker commit命令将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</p><p><a href="http://dockone.io/uploads/article/20190626/28059b3a499faba896263c0ff077fe3a.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/28059b3a499faba896263c0ff077fe3a.png" alt="24.png"></a></p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p><a href="http://dockone.io/uploads/article/20190626/b22cd304f28c715ae3ae6812476b222d.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/b22cd304f28c715ae3ae6812476b222d.png" alt="25.png"></a><br>docker build命令非常有趣，它会反复的执行多个命令。</p><p><a href="http://dockone.io/uploads/article/20190626/100712263ecf4544dd11602adc39ee3e.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/100712263ecf4544dd11602adc39ee3e.png" alt="26.png"></a></p><p>我们从上图可以看到，build命令根据Dockerfile文件中的FROM指令获取到镜像，然后重复地1）run（create和start）、2）修改、3）commit。在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。</p><p><a href="http://dockone.io/uploads/article/20190626/db64b3b38aff136d42e9ffeb81675bda.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/db64b3b38aff136d42e9ffeb81675bda.png" alt="27.png"></a></p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>命令会在运行中的容器执行一个新进程。</p><p><a href="http://dockone.io/uploads/article/20190626/184f9d55770ca036cb5b1e6d96ce4a12.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/184f9d55770ca036cb5b1e6d96ce4a12.png" alt="28.png"></a></p><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p>命令会提取出容器或者镜像最顶层的元数据。</p><p><a href="http://dockone.io/uploads/article/20190626/70cdbaf975c88bc83423d88be85476b5.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/70cdbaf975c88bc83423d88be85476b5.png" alt="29.png"></a></p><h3 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h3><p>命令会创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。</p><p><a href="http://dockone.io/uploads/article/20190626/1714c3dd524c807bf9c9b4d0fbe4d056.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/1714c3dd524c807bf9c9b4d0fbe4d056.png" alt="30.png"></a></p><h3 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h3><p>命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容（译者注：expoxt后的容器再import到Docker中，通过docker images –tree命令只能看到一个镜像；而save后的镜像则不同，它能够看到这个镜像的历史镜像）。</p><p><a href="http://dockone.io/uploads/article/20190626/b513dd5467f23fdd23523f60242d5dcb.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190626/b513dd5467f23fdd23523f60242d5dcb.png" alt="31.png"></a></p><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>命令递归地输出指定镜像的历史镜像。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deploy note</title>
      <link href="/2019/02/01/deploy-note/"/>
      <url>/2019/02/01/deploy-note/</url>
      
        <content type="html"><![CDATA[<h1 id="部署日记"><a href="#部署日记" class="headerlink" title="部署日记"></a>部署日记</h1><blockquote><p> Author：<a href="https://github.com/Voluee">Voluee</a> </p><p>记录WIndows和Linux还有MacOS系统下的开发工具的安装、部署、配置环境、命令等</p></blockquote><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="软件目录"><a href="#软件目录" class="headerlink" title="软件目录"></a>软件目录</h2><table><thead><tr><th align="center">开发工具</th><th align="center">开发工具</th><th align="center">开发工具</th><th align="center">开发工具</th></tr></thead><tbody><tr><td align="center"><a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora</a></td><td align="center"><a href="https://notepad-plus-plus.org/download" target="_blank" rel="noopener">Notepad++</a></td><td align="center"><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSC</a></td><td align="center"><a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener">IDEA</a></td></tr><tr><td align="center"><code>Java</code></td><td align="center"><a href="https://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang</a></td><td align="center"><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node.js</a></td><td align="center"><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a></td></tr><tr><td align="center"><a href="https://dev.mysql.com/downloads/mysql" target="_blank" rel="noopener">Mysql</a></td><td align="center"><a href="https://github.com/MicrosoftArchive/redis/releases">Redis</a></td><td align="center"><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">Mongodb</a></td><td align="center"><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">Kibana</a></td></tr><tr><td align="center">Navicat</td><td align="center"><a href="https://redisdesktop.com/" target="_blank" rel="noopener">R-Desktop</a></td><td align="center"><a href="https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip" target="_blank" rel="noopener">Robo3t</a></td><td align="center"><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a></td></tr><tr><td align="center"><a href="https://www.getpostman.com/downloads/" target="_blank" rel="noopener">Postman</a></td><td align="center"><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">Rabbitmq</a></td><td align="center"><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a></td><td align="center"><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">Jmeter</a></td></tr><tr><td align="center"><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></td><td align="center"><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a></td><td align="center"><a href="https://www.getpostman.com/downloads/" target="_blank" rel="noopener">Postman</a></td><td align="center"><a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">Jekins</a></td></tr><tr><td align="center"><a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">Wireshark</a></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><ul><li>RabbitMQ：<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a></li><li>Kibana(es)：<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a></li><li>MongoDB：<a href="http://localhost:27017" target="_blank" rel="noopener">http://localhost:27017</a></li><li>Redis：<a href="http://localhost:6379" target="_blank" rel="noopener">http://localhost:6379</a></li></ul><h2 id="CMD命令行代理设置"><a href="#CMD命令行代理设置" class="headerlink" title="CMD命令行代理设置"></a>CMD命令行代理设置</h2><ul><li><p>先设置好VPN的本地代理ip和端口</p><pre class=" language-bash"><code class="language-bash">  <span class="token keyword">set</span> http_proxy<span class="token operator">=</span>http://127.0.0.1:1080  <span class="token keyword">set</span> https_proxy<span class="token operator">=</span>http://127.0.0.1:1080  <span class="token keyword">set</span> http_proxy_user<span class="token operator">=</span>123  <span class="token keyword">set</span> http_proxy_pass<span class="token operator">=</span>123</code></pre></li><li><p>npm设置淘宝镜像</p><pre class=" language-bash"><code class="language-bash">命令行临时使用指定镜像（淘宝）<span class="token function">npm</span> --registry https://registry.npm.taobao.org <span class="token function">install</span> express使用cnpm代替npm<span class="token function">npm</span> <span class="token function">install</span> -g cnpm --registry<span class="token operator">=</span>https://registry.npm.taobao.org命令行永久更改使用指定镜像<span class="token function">npm</span> config <span class="token keyword">set</span> registry https://registry.npm.taobao.org查看目前使用的npm镜像的方法<span class="token function">npm</span> config get registry</code></pre></li></ul><h2 id="Mysql-5-7"><a href="#Mysql-5-7" class="headerlink" title="Mysql 5.7"></a>Mysql 5.7</h2><ul><li><p>修改环境变量</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">变量名</span><span class="token punctuation">:</span> MYSQL_HOME<span class="token key atrule">变量值</span><span class="token punctuation">:</span> C<span class="token punctuation">:</span>\developer\env\mysql<span class="token punctuation">-</span>5.7.25<span class="token punctuation">-</span>winx64<span class="token key atrule">path里添加</span><span class="token punctuation">:</span> %MYSQL_HOME%\bin</code></pre></li><li><p>创建<code>my.ini</code></p><pre class=" language-ini"><code class="language-ini"><span class="token selector">[mysqld]</span><span class="token constant">character-set-server</span><span class="token attr-value"><span class="token punctuation">=</span>utf8</span><span class="token constant">port</span> <span class="token attr-value"><span class="token punctuation">=</span> 3306</span><span class="token constant">sql_mode</span><span class="token attr-value"><span class="token punctuation">=</span>"STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION"</span><span class="token constant">default_storage_engine</span><span class="token attr-value"><span class="token punctuation">=</span>innodb</span><span class="token constant">innodb_buffer_pool_size</span><span class="token attr-value"><span class="token punctuation">=</span>1000M</span><span class="token constant">innodb_log_file_size</span><span class="token attr-value"><span class="token punctuation">=</span>50M</span><span class="token constant">basedir</span><span class="token attr-value"><span class="token punctuation">=</span>C:\developer\env\mysql-5.7.25-winx64</span><span class="token constant">datadir</span><span class="token attr-value"><span class="token punctuation">=</span>C:\developer\env\mysql-5.7.25-winx64\data</span><span class="token constant">max_connections</span><span class="token attr-value"><span class="token punctuation">=</span>200</span><span class="token selector">[mysql]</span><span class="token constant">default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>utf8</span><span class="token selector">[mysql.server]</span><span class="token constant">default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>utf8</span><span class="token selector">[mysql_safe]</span><span class="token constant">default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>utf8</span><span class="token selector">[client]</span><span class="token constant">port</span> <span class="token attr-value"><span class="token punctuation">=</span> 3306</span><span class="token constant">plugin-dir</span><span class="token attr-value"><span class="token punctuation">=</span>C:\developer\env\mysql-5.7.25-winx64\lib\plugin</span></code></pre></li><li><p>进入<code>bin</code>目录，cmd，执行以下命令</p><pre class=" language-bash"><code class="language-bash">mysqld --initialize在data目录下生成文件，xxx.err文件里说明了root账户的临时密码mysqld –install MySQL57net start MySQLmysql -u root -pALTER USER <span class="token string">'root'</span>@<span class="token string">'localhost'</span> IDENTIFIED BY <span class="token string">'qweasd'</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><ul><li>下载地址：<a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download</a></li><li>安装插件：lombok、jrebel、ali guide、mybatis log plugin</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li><p>下载Redis（工具包），下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p></li><li><p>在目录栏输入cmd后，执行redis的启动命令：redis-server.exe redis.windows.conf</p></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li><p>下载Elasticsearch6.2.2的zip包（工具包），下载地址：<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2</a></p></li><li><p>安装中文分词插件，在elasticsearch-6.2.2\bin目录下执行以下命令：</p><pre class=" language-bash"><code class="language-bash">  elasticsearch-plugin <span class="token function">install</span> https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip</code></pre></li><li><p>运行bin目录下的elasticsearch.bat启动Elasticsearch</p></li><li><p>下载Kibana,作为访问Elasticsearch的客户端，请下载6.2.2版本的zip包（工具包），下载地址：<a href="https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-windows-x86_64.zip" target="_blank" rel="noopener">https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-windows-x86_64.zip</a></p></li><li><p>运行bin目录下的kibana.bat，启动Kibana的服务端</p></li><li><p>访问<a href="http://localhost:5601" target="_blank" rel="noopener">http://localhost:5601</a> 打开Kibana的用户界面，选择<code>Dev Tools</code>标签，通过输入es的DSL语句来操作es</p></li></ul><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><ul><li><p>下载Mongodb安装包，下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a></p></li><li><p>选择安装路径进行安装，打开bin目录，有<code>mongo.exe(客户端)</code>和<code>mongod.exe(服务端)</code></p></li><li><p>在安装路径下创建<code>data\db</code>和<code>data\log</code>两个文件夹</p></li><li><p>在安装路径下创建<code>mongod.cfg</code>配置文件</p><pre class=" language-yaml"><code class="language-yaml">  <span class="token key atrule">systemLog</span><span class="token punctuation">:</span>      <span class="token key atrule">destination</span><span class="token punctuation">:</span> file      <span class="token key atrule">path</span><span class="token punctuation">:</span> c<span class="token punctuation">:</span>\developer\env\MongoDB\data\log\mongod.log  <span class="token key atrule">storage</span><span class="token punctuation">:</span>       <span class="token key atrule">dbPath</span><span class="token punctuation">:</span> c<span class="token punctuation">:</span>\developer\env\MongoDB\data\db</code></pre></li><li><p>安装为服务（运行命令需要用管理员权限）</p><pre class=" language-bash"><code class="language-bash">  C:\developer\env\MongoDB\bin\mongod.exe --config               <span class="token string">"C:\developer\env\MongoDB\mongod.cfg"</span> --install</code></pre></li><li><p>服务相关命令</p><pre class=" language-bash"><code class="language-bash">  启动服务：net start MongoDB  关闭服务：net stop MongoDB  移除服务：C:\developer\env\MongoDB\bin\mongod.exe --remove</code></pre></li><li><p>下载robo3t客户端程序（工具包）：<a href="https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip" target="_blank" rel="noopener">https://download.robomongo.org/1.2.1/windows/robo3t-1.2.1-windows-x86_64-3e50a65.zip</a></p></li><li><p>解压到指定目录，打开robo3t.exe并连接到localhost:27017</p></li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul><li><p>安装Erlang（工具包），下载地址：<a href="http://erlang.org/download/otpwin6421.3.exe" target="_blank" rel="noopener">http://erlang.org/download/otpwin6421.3.exe</a></p></li><li><p>安装RabbitMQ（工具包），下载地址：<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe" target="_blank" rel="noopener">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></p></li><li><p>安装完成后，进入RabbitMQ安装目录下的sbin目录</p></li><li><p>在地址栏输入cmd并回车启动命令行，然后输入以下命令启动管理功能：</p><pre class=" language-bash"><code class="language-bash">  rabbitmq-plugins <span class="token function">enable</span> rabbitmq_management</code></pre></li><li><p>访问地址查看是否安装成功：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p></li><li><p>输入账号密码并登录：guest guest</p></li><li><p>创建帐号并设置其角色为管理员</p></li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Docker环境安装"><a href="#Docker环境安装" class="headerlink" title="Docker环境安装"></a>Docker环境安装</h2><ul><li><p>安装yum-utils：</p><pre class=" language-bash"><code class="language-bash">  yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2</code></pre></li><li><p>为yum源添加docker仓库位置：</p><pre class=" language-bash"><code class="language-bash">  yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre></li><li><p>安装docker：</p><pre class=" language-bash"><code class="language-bash">  yum <span class="token function">install</span> docker-ce</code></pre></li><li><p>启动docker：</p><pre class=" language-bash"><code class="language-bash">  systemctl start docker</code></pre></li></ul><h2 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h2><ul><li><p>下载mysql5.7的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull mysql:5.7</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run -p 3306:3306 --name mysql \-v /mydata/mysql/log:/var/log/mysql \-v /mydata/mysql/data:/var/lib/mysql \-v /mydata/mysql/conf:/etc/mysql \-e MYSQL_ROOT_PASSWORD<span class="token operator">=</span>root  \-d mysql:5.7</code></pre></li><li><p>参数说明</p><pre class=" language-basic"><code class="language-basic">  <span class="token operator">-</span>p <span class="token number">3306</span><span class="token punctuation">:</span><span class="token number">3306</span>：将容器的<span class="token number">3306</span>端口映射到主机的<span class="token number">3306</span>端口  <span class="token operator">-</span>v <span class="token operator">/</span>mydata<span class="token operator">/</span>mysql<span class="token operator">/</span>conf<span class="token punctuation">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>mysql：将配置文件夹挂在到主机  <span class="token operator">-</span>v <span class="token operator">/</span>mydata<span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token function">log</span><span class="token punctuation">:</span><span class="token operator">/</span>var<span class="token operator">/</span><span class="token function">log</span><span class="token operator">/</span>mysql：将日志文件夹挂载到主机  <span class="token operator">-</span>v <span class="token operator">/</span>mydata<span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token punctuation">:</span><span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span>：将数据文件夹挂载到主机  <span class="token operator">-</span>e MYSQLROOTPASSWORD<span class="token operator">=</span>root：初始化root用户的密码</code></pre></li><li><p>进入运行mysql的docker容器：</p><pre class=" language-bash"><code class="language-bash">  docker <span class="token function">exec</span> -it mysql /bin/bash</code></pre></li><li><p>使用mysql命令打开客户端：</p><pre class=" language-bash"><code class="language-bash">  mysql -uroot -proot --default-character-set<span class="token operator">=</span>utf8</code></pre></li><li><p>创建mall数据库：</p><pre class=" language-bash"><code class="language-bash">  create database mall character <span class="token keyword">set</span> utf8</code></pre></li><li><p>安装上传下载插件，并将docment/sql/mall.sql上传到Linux服务器上：</p><pre class=" language-bash"><code class="language-bash">  yum -y <span class="token function">install</span> lrzsz</code></pre></li><li><p>将mall.sql文件拷贝到mysql容器的/目录下：</p><pre class=" language-bash"><code class="language-bash">  docker <span class="token function">cp</span> /mydata/mall.sql mysql:/</code></pre></li><li><p>将sql文件导入到数据库：</p><pre class=" language-bash"><code class="language-bash">  use mall<span class="token punctuation">;</span><span class="token function">source</span> /mall.sql<span class="token punctuation">;</span></code></pre></li><li><p>创建一个reader帐号并修改权限，使得任何ip都能访问：</p><pre class=" language-bash"><code class="language-bash">  grant all privileges on *.* to <span class="token string">'reader'</span> @<span class="token string">'%'</span> identified by <span class="token string">'123456'</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><ul><li><p>下载redis3.2的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull redis:3.2</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-d redis:3.2 redis-server --appendonly <span class="token function">yes</span></code></pre></li><li><p>进入redis容器使用redis-cli命令进行连接：</p><pre class=" language-bash"><code class="language-bash">  docker <span class="token function">exec</span> -it redis redis-cli</code></pre></li></ul><h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h3 id="下载nginx1-10的docker镜像："><a href="#下载nginx1-10的docker镜像：" class="headerlink" title="下载nginx1.10的docker镜像："></a>下载nginx1.10的docker镜像：</h3><pre class=" language-bash"><code class="language-bash">docker pull nginx:1.10</code></pre><h3 id="从容器中拷贝nginx配置"><a href="#从容器中拷贝nginx配置" class="headerlink" title="从容器中拷贝nginx配置"></a>从容器中拷贝nginx配置</h3><ul><li><p>先运行一次容器（为了拷贝配置文件）：</p><pre class=" language-bash"><code class="language-bash">  docker run -p 80:80 --name nginx \-v /mydata/nginx/html:/usr/share/nginx/html \-v /mydata/nginx/logs:/var/log/nginx  \-d nginx:1.17.1</code></pre></li><li><p>将容器内的配置文件拷贝到指定目录：</p><pre class=" language-bash"><code class="language-bash">  docker container <span class="token function">cp</span> nginx:/etc/nginx /mydata/nginx/</code></pre></li><li><p>修改文件名称：</p><pre class=" language-bash"><code class="language-bash">  <span class="token function">mv</span> nginx conf</code></pre></li><li><p>终止并删除容器：</p><pre class=" language-bash"><code class="language-bash">  docker stop nginx  docker <span class="token function">rm</span> nginx</code></pre></li></ul><h3 id="使用docker命令启动："><a href="#使用docker命令启动：" class="headerlink" title="使用docker命令启动："></a>使用docker命令启动：</h3><pre class=" language-bash"><code class="language-bash">docker run -p 80:80 --name nginx \-v /mydata/nginx/html:/usr/share/nginx/html \-v /mydata/nginx/logs:/var/log/nginx  \-v /mydata/nginx/conf:/etc/nginx \-d nginx:1.17.1</code></pre><h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><ul><li><p>下载rabbitmq3.7.15的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull rabbitmq:3.7.15</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run -d --name rabbitmq \--publish 5671:5671 --publish 5672:5672 --publish 4369:4369 \--publish 25672:25672 --publish 15671:15671 --publish 15672:15672 \rabbitmq:3.7.15</code></pre></li><li><p>进入容器并开启管理功能：</p><pre class=" language-bash"><code class="language-bash">  docker <span class="token function">exec</span> -it rabbitmq /bin/bash  rabbitmq-plugins <span class="token function">enable</span> rabbitmq_management</code></pre></li><li><p>开启防火墙：</p><pre class=" language-bash"><code class="language-bash">  systemctl start firewalld  systemctl stop firewalld  firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>15672/tcp --permanent  firewall-cmd --reload</code></pre></li></ul><h2 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h2><ul><li><p>下载elasticsearch6.4.0的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull elasticsearch:6.4.0</code></pre></li><li><p>修改虚拟内存区域大小，否则会因为过小而无法启动:</p><pre class=" language-bash"><code class="language-bash">  sysctl -w vm.max_map_count<span class="token operator">=</span>262144</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run -p 9200:9200 -p 9300:9300 --name elasticsearch \-e <span class="token string">"discovery.type=single-node"</span> \-e <span class="token string">"cluster.name=elasticsearch"</span> \-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \-d elasticsearch:6.4.0</code></pre></li><li><p>启动时会发现/usr/share/elasticsearch/data目录没有访问权限，只需要修改/mydata/elasticsearch/data目录的权限，再重新启动。</p><pre class=" language-bash"><code class="language-bash">  <span class="token function">chmod</span> 777 /mydata/elasticsearch/data/</code></pre></li><li><p>安装中文分词器IKAnalyzer，并重新启动：</p><pre class=" language-bash"><code class="language-bash">  docker <span class="token function">exec</span> -it elasticsearch /bin/bash<span class="token comment" spellcheck="true">#此命令需要在容器中运行</span>  elasticsearch-plugin <span class="token function">install</span> https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.0/elasticsearch-analysis-ik-6.4.0.zip   docker restart elasticsearch</code></pre></li><li><p>开启防火墙：</p><pre class=" language-bash"><code class="language-bash">  firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>9200/tcp --permanent  firewall-cmd --reload</code></pre></li><li><p>访问会返回版本信息：<a href="http://192.168.3.101:9200/" target="_blank" rel="noopener">http://192.168.3.101:9200/</a> </p></li></ul><h2 id="kibana安装"><a href="#kibana安装" class="headerlink" title="kibana安装"></a>kibana安装</h2><ul><li><p>下载kibana6.4.0的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull kibana:6.4.0</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run --name kibana -p 5601:5601 \--link elasticsearch:es \-e <span class="token string">"elasticsearch.hosts=http://es:9200"</span> \-d kibana:6.4.0</code></pre></li><li><p>开启防火墙：</p><pre class=" language-bash"><code class="language-bash">  firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>5601/tcp --permanentfirewall-cmd --reload</code></pre></li><li><p>访问地址进行测试：<a href="http://192.168.3.101:5601" target="_blank" rel="noopener">http://192.168.3.101:5601</a> </p></li></ul><h2 id="Mongodb安装"><a href="#Mongodb安装" class="headerlink" title="Mongodb安装"></a>Mongodb安装</h2><ul><li><p>下载mongo3.2的docker镜像：</p><pre class=" language-bash"><code class="language-bash">  docker pull mongo:3.2</code></pre></li><li><p>使用docker命令启动：</p><pre class=" language-bash"><code class="language-bash">  docker run -p 27017:27017 --name mongo \-v /mydata/mongo/db:/data/db \-d mongo:3.2</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker install</title>
      <link href="/2019/01/04/docker-install/"/>
      <url>/2019/01/04/docker-install/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-install"><a href="#Docker-install" class="headerlink" title="Docker install"></a>Docker install</h1><blockquote><p> Author：<a href="https://github.com/Voluee">Voluee</a> </p></blockquote><h2 id="Docker-环境安装"><a href="#Docker-环境安装" class="headerlink" title="Docker 环境安装"></a>Docker 环境安装</h2><ul><li><p>安装yum-utils：</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2</code></pre></li><li><p>为yum源添加docker仓库位置：</p><pre class=" language-bash"><code class="language-bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre></li><li><p>安装docker:</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> docker-ce</code></pre></li><li><p>启动docker:</p><pre class=" language-bash"><code class="language-bash">systemctl start docker</code></pre></li></ul><h2 id="Docker-镜像常用命令"><a href="#Docker-镜像常用命令" class="headerlink" title="Docker 镜像常用命令"></a>Docker 镜像常用命令</h2><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><pre class=" language-bash"><code class="language-bash">docker search java</code></pre><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><pre class=" language-bash"><code class="language-bash">docker pull java:8</code></pre><h3 id="如何查找镜像支持的版本"><a href="#如何查找镜像支持的版本" class="headerlink" title="如何查找镜像支持的版本"></a>如何查找镜像支持的版本</h3><blockquote><p>由于docker search命令只能查找出是否有该镜像，不能找到该镜像支持的版本，所以我们需要通过docker hub来搜索支持的版本。</p></blockquote><ul><li>进入docker hub的官网，地址：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></li><li>然后搜索需要的镜像</li><li>查看镜像支持的版本</li><li>进行镜像的下载操作：</li></ul><pre class=" language-bash"><code class="language-bash">docker pull nginx:1.17.0</code></pre><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><pre class=" language-bash"><code class="language-bash">docker images</code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><ul><li>指定名称删除镜像</li></ul><pre class=" language-bash"><code class="language-bash">docker rmi java:8</code></pre><ul><li>指定名称删除镜像（强制）</li></ul><pre class=" language-bash"><code class="language-bash">docker rmi -f java:8</code></pre><ul><li>强制删除所有镜像</li></ul><pre class=" language-bash"><code class="language-bash">docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images<span class="token variable">)</span></span></code></pre><h2 id="Docker-容器常用命令"><a href="#Docker-容器常用命令" class="headerlink" title="Docker 容器常用命令"></a>Docker 容器常用命令</h2><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><pre class=" language-bash"><code class="language-bash">docker run -p 80:80 --name nginx -d nginx:1.17.0</code></pre><ul><li>-d选项：表示后台运行</li><li>–name选项：指定运行后容器的名字为nginx,之后可以通过名字来操作容器</li><li>-p选项：指定端口映射，格式为：hostPort:containerPort</li></ul><h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><ul><li>列出运行中的容器：</li></ul><pre class=" language-bash"><code class="language-bash">docker <span class="token function">ps</span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwlTaMR6AI8jfpnz14uqicZELX37FXwV479Eq2WnWu4UZJMMu0tGH9AwD5Hlg9YPq6oia1I5HE69wI6w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><ul><li>列出所有容器</li></ul><pre class=" language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwlTaMR6AI8jfpnz14uqicZELICldQWbuYSDaOh8Xe8eZcjajbbeXU2hG5XvOibibiclU8kzhLIhV9C2rg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># $ContainerName及$ContainerId可以用docker ps命令查询出来docker stop $ContainerName(或者$ContainerId)</span></code></pre><p>比如：</p><pre class=" language-bash"><code class="language-bash">docker stop nginx<span class="token comment" spellcheck="true">#或者docker stop c5f5d5125587</span></code></pre><h3 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h3><pre class=" language-bash"><code class="language-bash">docker <span class="token function">kill</span> <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><h3 id="启动已停止的容器"><a href="#启动已停止的容器" class="headerlink" title="启动已停止的容器"></a>启动已停止的容器</h3><pre class=" language-bash"><code class="language-bash">docker start <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><ul><li>先查询出容器的pid：</li></ul><pre class=" language-bash"><code class="language-bash">docker inspect --format <span class="token string">"{{.State.Pid}}"</span> <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><ul><li>根据容器的pid进入容器：</li></ul><pre class=" language-bash"><code class="language-bash">nsenter --target <span class="token string">"<span class="token variable">$pid</span>"</span> --mount --uts --ipc --net --pid</code></pre><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul><li>删除指定容器：</li></ul><pre class=" language-bash"><code class="language-bash">docker <span class="token function">rm</span> <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><ul><li>强制删除所有容器；</li></ul><pre class=" language-bash"><code class="language-bash">docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -a -q<span class="token variable">)</span></span></code></pre><h3 id="查看容器的日志"><a href="#查看容器的日志" class="headerlink" title="查看容器的日志"></a>查看容器的日志</h3><pre class=" language-bash"><code class="language-bash">docker logs <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><h3 id="查看容器的IP地址"><a href="#查看容器的IP地址" class="headerlink" title="查看容器的IP地址"></a>查看容器的IP地址</h3><pre class=" language-bash"><code class="language-bash">docker inspect --format <span class="token string">'{{ .NetworkSettings.IPAddress }}'</span> <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwlTaMR6AI8jfpnz14uqicZELow5MRkB2Dhg5tjl2o1NFfxOdmw89l2qDufNfWuIuWtic8nx2icicVc1yg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h3 id="同步宿主机时间到容器"><a href="#同步宿主机时间到容器" class="headerlink" title="同步宿主机时间到容器"></a>同步宿主机时间到容器</h3><pre class=" language-bash"><code class="language-bash">docker <span class="token function">cp</span> /etc/localtime <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span>:/etc/</code></pre><h3 id="在宿主机查看docker使用cpu、内存、网络、io情况"><a href="#在宿主机查看docker使用cpu、内存、网络、io情况" class="headerlink" title="在宿主机查看docker使用cpu、内存、网络、io情况"></a>在宿主机查看docker使用cpu、内存、网络、io情况</h3><ul><li><p>查看指定容器情况：</p><pre class=" language-bash"><code class="language-bash">docker stats <span class="token variable">$ContainerName</span><span class="token punctuation">(</span>或者<span class="token variable">$ContainerId</span><span class="token punctuation">)</span></code></pre></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/CKvMdchsUwlTaMR6AI8jfpnz14uqicZELFAe0m9OMc2YbBg9pVTWAdSQ7jRrjicwUaeeGJMjV5ZicyGLnYY6nmg3w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><ul><li><p>查看所有容器情况：</p><pre class=" language-bash"><code class="language-bash">docker stats -a</code></pre></li></ul><h3 id="进入Docker容器内部的bash"><a href="#进入Docker容器内部的bash" class="headerlink" title="进入Docker容器内部的bash"></a>进入Docker容器内部的bash</h3><pre class=" language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it <span class="token variable">$ContainerName</span> /bin/bash</code></pre><h2 id="修改Docker镜像的存放位置"><a href="#修改Docker镜像的存放位置" class="headerlink" title="修改Docker镜像的存放位置"></a>修改Docker镜像的存放位置</h2><ul><li><p>查看Docker镜像的存放位置：</p><pre class=" language-bash"><code class="language-bash">docker info <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Docker Root Dir"</span></code></pre></li><li><p>关闭Docker服务：</p><pre class=" language-bash"><code class="language-bash">systemctl stop docker</code></pre></li><li><p>移动目录到目标路径：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mv</span> /var/lib/docker /mydata/docker</code></pre></li><li><p>建立软连接：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ln</span> -s /mydata/docker /var/lib/docker</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXPLAIN详解</title>
      <link href="/2018/11/11/explain-detail/"/>
      <url>/2018/11/11/explain-detail/</url>
      
        <content type="html"><![CDATA[<h1 id="EXPLAIN详解"><a href="#EXPLAIN详解" class="headerlink" title="EXPLAIN详解"></a>EXPLAIN详解</h1><blockquote><p> Author：<a href="https://github.com/Voluee">Voluee</a> </p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>一般语法：<code>EXPLAIN [sql];</code></li></ul><img src="https://i.postimg.cc/Pxq7bvSS/image.jpg" width="700"><ul><li>详细参数语法：<ul><li><code>EXPLAIN EXTENDED [sql];SHOW WARNINGS;</code>，可以获得MySQL<code>优化后</code>的语句</li><li><code>EXPLAIN PARTITIONS</code>： 相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区</li></ul></li></ul><img src="https://i.postimg.cc/0Qbsk415/image.jpg" width="700"><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><blockquote><p>id 列的编号是 SELECT 的序列号，有几个 SELECT 就有几个 id，并且 id 的顺序是按 SELECT 出现的顺序增长的。</p></blockquote><ul><li>表示查询中执行select子句或操作表的顺序</li><li>id值越大优先级越高，越先被执行</li><li>id相同，执行顺序由上至下</li></ul><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><blockquote><p>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p></blockquote><ul><li><code>SIMPLE</code>：查询中不包含子查询或者UNION</li><li><code>PRIMARY</code>：查询中若包含任何复杂的子部分，最外层的查询</li><li><code>SUBQUERY</code>：在SELECT或WHERE列表中包含了的子查询</li><li><code>DERIVED</code>：在FROM列表中包含的子查询；UNION包含在FROM子句的子查询中，外层的SELECT</li><li><code>UNION</code>：若第二个SELECT出现在UNION之后，则被标记为UNION</li><li><code>UNION RESULT</code>：从UNION表获取结果的SELECT</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><blockquote><p>这一列表示关联类型或访问类型，即 MySQL 决定如何查找表中的行，查找数据行记录的大概范围。</p></blockquote><ul><li>最优到最差为：<code>NULL&gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code></li><li><code>ALL</code>：Full Table Scan， MySQL将遍历全表以找到匹配的行</li><li><code>index</code>：Full Index Scan，index与ALL区别为index类型只遍历索引树</li><li><code>range</code>：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询<ul><li>range访问类型的不同形式的索引访问性能差异</li></ul></li><li><code>ref</code>：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找</li><li><code>eq_ref</code>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li><code>const、system</code>：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量<ul><li>system是const类型的特例，当查询的表只有一行的情况下， 使用system</li></ul></li><li><code>NULL</code>：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引</li></ul><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><blockquote><p>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p></blockquote><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><blockquote><p>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</p></blockquote><ul><li>查询中若使用了覆盖索引，则该索引仅出现在key列表中</li></ul><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><blockquote><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</p></blockquote><ul><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote><p>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p></blockquote><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><blockquote><p>表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</p></blockquote><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><blockquote><p>包含不适合在其他列中显示但十分重要的额外信息</p></blockquote><ul><li><code>Using index</code>：该值表示相应的select操作中使用了覆盖索引（Covering Index）<ul><li>TIPS：覆盖索引（Covering Index）：MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件包含所有满足查询需要的数据的索引称为 <strong>覆盖索引</strong>（Covering Index）</li><li>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可<code>select *</code>，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降</li></ul></li><li><code>Using where</code>：表示MySQL服务器在存储引擎受到记录后进行“后过滤”（Post-filter），如果查询未能使用索引，Using where的作用只是提醒我们MySQL将用where子句来过滤结果集</li><li><code>Using temporary</code>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</li><li><code>Using filesort</code>：MySQL中无法利用索引完成的排序操作称为“文件排序”</li></ul><h2 id="MySQL执行计划的局限"><a href="#MySQL执行计划的局限" class="headerlink" title="MySQL执行计划的局限"></a>MySQL执行计划的局限</h2><ul><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>部分统计信息是估算的，并非精确值</li><li>EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL调优实例与总结</title>
      <link href="/2018/11/07/mysql-index/"/>
      <url>/2018/11/07/mysql-index/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL调优实例与总结"><a href="#SQL调优实例与总结" class="headerlink" title="SQL调优实例与总结"></a>SQL调优实例与总结</h1><blockquote><p>Author：<a href="https://github.com/Voluee">Voluee</a><br>MySQL版本：5.5</p><p>这是一篇从实例出发的sql调优教程，文章开头有生成数据的语句。一键生成环境，快速上手调优。</p></blockquote><h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h2><pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> student<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> student<span class="token punctuation">(</span>    s_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    s_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span> <span class="token keyword">default</span> <span class="token keyword">charset</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> course<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> course<span class="token punctuation">(</span>    c_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    c_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span> <span class="token keyword">default</span> <span class="token keyword">charset</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> sc<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">exists</span> sc<span class="token punctuation">(</span>    sc_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    s_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    c_id <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">,</span>    score <span class="token keyword">int</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span> <span class="token keyword">engine</span> <span class="token operator">=</span> <span class="token keyword">innodb</span> <span class="token keyword">default</span> <span class="token keyword">charset</span> <span class="token operator">=</span> utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 以下数据表对应的数据记录数</span><span class="token comment" spellcheck="true">--      10  course</span><span class="token comment" spellcheck="true">--  70,000  student</span><span class="token comment" spellcheck="true">-- 700,000  sc</span><span class="token comment" spellcheck="true">-- 根据以上要求准备测试数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> course <span class="token punctuation">(</span> c_id<span class="token punctuation">,</span> c_name <span class="token punctuation">)</span>     <span class="token keyword">SELECT</span>         <span class="token boolean">NULL</span> <span class="token keyword">AS</span> c_id<span class="token punctuation">,</span>        concat<span class="token punctuation">(</span> <span class="token string">'course'</span><span class="token punctuation">,</span> ID <span class="token punctuation">)</span> <span class="token keyword">AS</span> c_name     <span class="token keyword">FROM</span>        information_schema<span class="token punctuation">.</span><span class="token punctuation">`</span>COLLATIONS<span class="token punctuation">`</span>     <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ID <span class="token keyword">ASC</span>     <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 创建7w条空数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> student <span class="token punctuation">(</span> s_id<span class="token punctuation">,</span> s_name <span class="token punctuation">)</span>     <span class="token keyword">SELECT</span>         <span class="token boolean">NULL</span> <span class="token keyword">AS</span> s_id<span class="token punctuation">,</span>        <span class="token string">''</span> <span class="token keyword">AS</span> s_name     <span class="token keyword">FROM</span>        <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">AS</span> column_order_id <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token punctuation">`</span><span class="token keyword">COLUMNS</span><span class="token punctuation">`</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3500</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> t        <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span>             <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> <span class="token number">1</span> <span class="token keyword">AS</span> collation_order_id <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span><span class="token punctuation">`</span><span class="token keyword">COLUMNS</span><span class="token punctuation">`</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> t2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 给7w条数据赋值</span><span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> s_name <span class="token operator">=</span> concat<span class="token punctuation">(</span> <span class="token string">'student'</span><span class="token punctuation">,</span> s_id <span class="token punctuation">)</span> <span class="token keyword">WHERE</span>    s_name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 创建70w条数据，10 * 7w </span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sc <span class="token punctuation">(</span> sc_id<span class="token punctuation">,</span> s_id<span class="token punctuation">,</span> c_id<span class="token punctuation">,</span> score <span class="token punctuation">)</span>     <span class="token keyword">SELECT</span>         <span class="token boolean">NULL</span> <span class="token keyword">AS</span> sc_id<span class="token punctuation">,</span>        t2<span class="token punctuation">.</span>s_id<span class="token punctuation">,</span>        t<span class="token punctuation">.</span>c_id<span class="token punctuation">,</span>        ceiling<span class="token punctuation">(</span> rand<span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token punctuation">)</span> <span class="token keyword">AS</span> score     <span class="token keyword">FROM</span>        course <span class="token keyword">AS</span> t        <span class="token keyword">CROSS</span> <span class="token keyword">JOIN</span> student <span class="token keyword">AS</span> t2<span class="token punctuation">;</span></code></pre><h2 id="单索引调优过程"><a href="#单索引调优过程" class="headerlink" title="单索引调优过程"></a>单索引调优过程</h2><p>查询目的：查找语文考100分的考生(c_id = 1)</p><h3 id="in查询"><a href="#in查询" class="headerlink" title="in查询"></a>in查询</h3><p>查询语句如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    s<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span>    student s <span class="token keyword">WHERE</span>    s<span class="token punctuation">.</span>s_id <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> sc<span class="token punctuation">.</span>s_id <span class="token keyword">FROM</span> sc sc <span class="token keyword">WHERE</span> sc<span class="token punctuation">.</span>c_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> sc<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">)</span></code></pre><p>执行时间：<code>30118.381s</code>，没有实际测过（参考来的），反正很慢很慢很慢就是了。</p><p>看一下执行计划（不懂的<a href="http://132.232.92.124/2019/06/06/explain/" target="_blank" rel="noopener">点击详解</a>）：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> s<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> student s <span class="token keyword">WHERE</span> s<span class="token punctuation">.</span>s_id <span class="token operator">IN</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> sc<span class="token punctuation">.</span>s_id <span class="token keyword">FROM</span> sc sc <span class="token keyword">WHERE</span> sc<span class="token punctuation">.</span>c_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> sc<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">)</span></code></pre><img src="https://i.postimg.cc/3Nf0yVdL/image.jpg" width="800"><p>查看结果发现没有用到索引，type全是ALL，那么首先想到的就是建立一个索引，建立索引的字段当然是在where条件的字段。</p><p>先给sc表的c_id和score建个索引：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">index</span> sc_c_id_index <span class="token keyword">on</span> sc<span class="token punctuation">(</span>c_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">index</span> sc_score_index <span class="token keyword">on</span> sc<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">index</span> sc_s_id_index <span class="token keyword">on</span> sc<span class="token punctuation">(</span>s_id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>再次执行上述查询语句，时间为：<code>0.983s</code>，明显变快很多倍</p><p>看一下执行计划：</p><img src="https://i.postimg.cc/NfLHhszZ/in.jpg" width="800"><p>再查看引擎优化后的sql（EXPLAIN EXTENDED SQL; SHOW WARNINGS;）：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s_id<span class="token punctuation">`</span> <span class="token keyword">AS</span> <span class="token punctuation">`</span>s_id<span class="token punctuation">`</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s_name<span class="token punctuation">`</span> <span class="token keyword">AS</span> <span class="token punctuation">`</span>s_name<span class="token punctuation">`</span> <span class="token keyword">FROM</span>    <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>student<span class="token punctuation">`</span> <span class="token punctuation">`</span>s<span class="token punctuation">`</span> <span class="token keyword">WHERE</span>    <span class="token operator">&lt;</span> in_optimizer <span class="token operator">></span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token operator">&lt;</span> <span class="token keyword">EXISTS</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span>    <span class="token number">1</span> <span class="token keyword">FROM</span>    <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>sc<span class="token punctuation">`</span> <span class="token keyword">WHERE</span>    <span class="token punctuation">(</span>    <span class="token punctuation">(</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>sc<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>score<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token number">100</span> <span class="token punctuation">)</span>     <span class="token operator">AND</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>sc<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>c_id<span class="token punctuation">`</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">)</span>     <span class="token operator">AND</span> <span class="token punctuation">(</span> <span class="token operator">&lt;</span> CACHE <span class="token operator">></span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s_id<span class="token punctuation">`</span> <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">`</span>test<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>sc<span class="token punctuation">`</span><span class="token punctuation">.</span><span class="token punctuation">`</span>s_id<span class="token punctuation">`</span> <span class="token punctuation">)</span>     <span class="token punctuation">)</span>     <span class="token punctuation">)</span> </code></pre><p>从执行计划可以看到MySQL将sql优化成了EXISTS子句，即先执行外层查询，再执行里层查询，这样久要循环<code>69987 * 4</code>次，从执行计划可以看到只走了sc的s_id的索引，耗时相对较长，所以下面改用连接查询测试。</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>查询语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>    s<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span>    student s    <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> sc sc <span class="token keyword">ON</span> sc<span class="token punctuation">.</span>s_id <span class="token operator">=</span> s<span class="token punctuation">.</span>s_id <span class="token keyword">WHERE</span>    sc<span class="token punctuation">.</span>c_id <span class="token operator">=</span> <span class="token number">1</span>     <span class="token operator">AND</span> sc<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>先删除之前的索引，执行上述查询语句，耗时：<code>0.213s</code>，效率非常快，看看执行计划，</p><img src="https://i.postimg.cc/nhD9zdZk/image.jpg" width="800"><p>可以看到执行计划先走的student表的主键索引，再走sc全表，不加索引是in查询的<code>5倍</code>效率</p><p>我们给sc的c_id和score建立个索引试试</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">index</span> sc_c_id_index <span class="token keyword">on</span> sc<span class="token punctuation">(</span>c_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">index</span> sc_score_index <span class="token keyword">on</span> sc<span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="https://i.postimg.cc/bv0G0sZS/image.jpg" width="800"><p>执行上述查询语句，耗时：<code>0.054s</code>，从执行计划可以看到，走了c_id和score两个索引一共只有<code>1396 * 1</code>的查询次数，查询速度提升了4倍。相比in查询提高了<code>20倍</code>效率。</p><p>附图SQL语句执行顺序：</p><p><code>FROM &gt; ON &gt; JOIN &gt; WHERE &gt; GROUP BY&gt; WITH &gt; HAVING &gt; SELECT &gt; DISTINCT &gt; ORDER BY&gt; LIMIT</code></p><img src="https://i.postimg.cc/DZ2SxnGj/image.png" width="300"><h2 id="联合索引的调优"><a href="#联合索引的调优" class="headerlink" title="联合索引的调优"></a>联合索引的调优</h2><img src="https://i.postimg.cc/fLBJFpjw/image.jpg" width="800"><ul><li>其实从执行计划的type就能看出来sc的type是<code>index_merge</code>，这里用到了<code>intersect</code>并集操作，即两个索引同时检索的结果再求并集，再看字段<code>score</code>和<code>c_id</code>的区分度，单从一个字段看从SC表检索，c_id = 2检索的结果是<code>142158</code>，score = 84的结果是<code>6851</code>，而<code>c_id = 2 and score = 84</code> 的结果是<code>1390</code>，即这两个字段联合起来的区分度是比较高的，因此建立联合索引查询效率将会更高。</li><li>另外一个角度看，该表的数据是70w，以后会更多，就索引存储而言，都是不小的数目，随着数据量的增加，索引就不能全部加载到内存，而是要从磁盘去读取，这样索引的个数越多，读磁盘的开销就越大，因此根据具体业务情况建立<code>多列的联合索引</code>是必要的，那么我们来试试吧。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> SC <span class="token keyword">drop</span> <span class="token keyword">index</span> sc_c_id_index<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> SC <span class="token keyword">drop</span> <span class="token keyword">index</span> sc_score_index<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">index</span> sc_c_id_score_index <span class="token keyword">on</span> SC<span class="token punctuation">(</span>c_id<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="https://i.postimg.cc/qqqzdwj2/image.jpg" width="800"><p>执行上述查询语句，消耗时间为：<code>0.029s</code>，这个速度还是可以接受的，快了<code>一倍</code>，随着数据量越大效果越明显。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>就是查询的列都建立了索引<code>至少索引要包含查询的列</code>，这样在获取结果集的时候不用再去磁盘获取其它列的数据，直接返回索引数据即可</p><p>简洁说就是<code>select</code>尽量不返回<code>*</code>而是返回需要的有索引的列，如下面所示，第二条效率大于第一条</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> name<span class="token operator">=</span> <span class="token string">'小明'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">AND</span> POSITION <span class="token operator">=</span><span class="token string">'Java'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> NAME<span class="token punctuation">,</span> age<span class="token punctuation">,</span> POSITION <span class="token keyword">FROM</span> employees <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span> <span class="token string">'小明'</span> <span class="token operator">AND</span> age <span class="token operator">=</span> <span class="token number">22</span> <span class="token operator">AND</span> POSITION <span class="token operator">=</span><span class="token string">'Java'</span><span class="token punctuation">;</span></code></pre><h3 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h3><p>假设 a、b、c 为联合索引，即<code>create index index_a_b_c on table(a,b,c);</code></p><table><thead><tr><th>WHERE 语句</th><th>索引使用情况</th></tr></thead><tbody><tr><td>WHERE a = ‘小明’</td><td>使用到 a</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘李磊’</td><td>使用到 a 、b</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘李磊’ AND c = ‘韩梅梅’</td><td>使用到 a、b、c</td></tr><tr><td>WHERE b = ‘李磊’ 或者 WHERE b = ‘李磊’ AND c = ‘韩梅梅’ 或者 WHERE c = ‘韩梅梅’</td><td>没有用到</td></tr><tr><td>WHERE a = ‘小明’ AND c = ‘韩梅梅’</td><td>a 用到了，c 没有用到，因为 b 中间断了</td></tr><tr><td>WHERE a = ‘小明’ AND b &gt; ‘李磊’ AND c = ‘韩梅梅’</td><td>a、b 用到了，c 不能用在范围后</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘李磊%’ AND c = ‘韩梅梅’</td><td>使用到 a、b、c</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘%李磊’ AND c = ‘韩梅梅’</td><td>只用到 a</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘%李磊%’ AND c = ‘韩梅梅’</td><td>只用到 a</td></tr><tr><td>WHERE a = ‘小明’ AND b = ‘李%磊%’ AND c = ‘韩梅梅’</td><td>使用到 a、b、c</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="索引优化相关"><a href="#索引优化相关" class="headerlink" title="索引优化相关"></a>索引优化相关</h3><ul><li>表的主键、外键必须有索引</li><li>数据量超过300的表应该有索引</li><li>索引应该建在选择性高的字段上</li><li>排序字段上需要建立索引（<code>ORDER BY</code>）</li><li>分组字段上需要建立索引（<code>GROUP BY</code>）</li><li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引</li><li>WHERE条件字段上需要建立索引（<code>WHERE</code>）</li><li>多表连接的字段上需要建立索引，这样可以极大的提高表连接的效率（<code>LEFT JOIN</code>、<code>RIGHT JOIN</code>、<code>INNER JOIN</code>）</li><li>嵌套子查询效率比较低，可以将其优化成连接查询（少用<code>IN</code>，多用<code>JOIN</code>）</li><li>频繁进行数据操作的表，不要建立太多的索引</li><li>连接表时，可以先用where条件对表进行过滤，然后做表连接（虽然MySQL会对连表语句做优化）</li><li>复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替<ul><li>正确选择复合索引中的主列字段，一般是选择性较好的字段</li><li>如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引</li><li>如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段</li><li>果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引</li><li>复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引</li></ul></li><li>学会分析sql执行计划，mysql会对sql进行优化，所以分析执行计划很重要</li><li>尽量使用覆盖索引，能增加查询效率</li><li><strong><code>删除数据，修改索引字段，新增操作都会对索引进行维护，维护开销大，同时需要更大的磁盘空间，需要综合平衡，取最优点</code></strong></li></ul><h3 id="调优建议相关"><a href="#调优建议相关" class="headerlink" title="调优建议相关"></a>调优建议相关</h3><ul><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，</li></ul><pre><code>select id from t where num is null;</code></pre><ul><li>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></code></pre><ul><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p></li><li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">or</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span></code></pre><p>​        可以这样查询：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span></code></pre><ul><li>in 和 not in 也要慎用，否则会导致全表扫描，如：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>对于连续的数值，能用 between 就不要用 in 了：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><ul><li>下面的查询也将导致全表扫描：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%c%'</span><span class="token punctuation">;</span></code></pre><p>若要提高效率，可以考虑全文检索。</p><ul><li>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span> <span class="token punctuation">;</span></code></pre><ul><li>可以改为强制查询使用索引：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span> <span class="token punctuation">;</span></code></pre><ul><li>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>可以这样查询：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span></code></pre><ul><li>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> substring<span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#name 以 abc 开头的 id</span></code></pre><p>​        应改为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'abc%'</span><span class="token punctuation">;</span></code></pre><ul><li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</p></li><li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</p><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p></li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> col1<span class="token punctuation">,</span>col2 <span class="token keyword">into</span> <span class="token comment" spellcheck="true">#t from t where 1=0;</span></code></pre><ul><li>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment" spellcheck="true">#t(…);</span></code></pre><ul><li>很多时候用 exists 代替 in 是一个好的选择：</li></ul><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> <span class="token number">a</span> <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> <span class="token number">b</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​            用下面的语句替换：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> <span class="token number">a</span> <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token number">b</span> <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">a</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 <strong>*,male、female 几乎各一半，那么即使在 *</strong> 上建 了索引也对查询效率起不了作用。</p></li><li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用 select * from t ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</p></li><li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 create table,然后 insert.</p></li><li><p>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ,然后 drop table ,这样可以避免系统表的较长时间锁定。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</p></li><li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更 有效。</p></li><li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p></li><li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ,在结束时设置 SET NOCOUNT OFF .无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：</p><p>a.有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;</p><p>b.经常同时存取多列，且每列都含有重复值可考虑建立组合索引;</p><p>c.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</p></li><li><p>定期分析表和检查表。</p></li></ul><pre><code>分析表的语法：ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name[, tbl_name]...</code></pre><p>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。</p><pre><code>例如分析一个数据表：analyze table table_name检查表的语法：CHECK TABLE tb1_name[,tbl_name]...[option]...option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}</code></pre><p>检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新</p><p>CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</p><ul><li>定期优化表。</li></ul><pre><code>优化表的语法：OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name [,tbl_name]...</code></pre><p>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。</p><pre><code>例如： optimize table table_name</code></pre><p>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://www.cnblogs.com/tangyanbo/p/4462734.html" target="_blank" rel="noopener">一次非常有意思的sql优化经历</a><br><a href="https://juejin.im/post/5ce61072f265da1b5e72cb20" target="_blank" rel="noopener">MySQL 性能调优专题二（Explain执行计划使用详解）</a><br><a href="https://www.cnblogs.com/tangyanbo/p/6378741.html" target="_blank" rel="noopener">sql查询调优之where条件排序字段以及limit使用索引的奥秘</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
